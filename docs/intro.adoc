= Getting Started:

----
$ poetry install
$ poetry shell
$ python -m bucket.example
----

== About:

Below is a breakdown of each part of Bucket, with information on how to create coverpoints then sample, export and merge coverage.

=== Coverpoints

A coverpoint consists of one or more axes, which are then crossed. Each possible combination of the axes values is called a bucket. Each bucket has a default goal of 10 hits, which can be modified as required, or can be made illegal or ignored. 

Each new coverpoint should inherit from the Coverpoint class, and requires a 'name', 'description' and an optional 'trigger'. (Triggers are to be added soon). 

[source,python]
----
class MyCoverpoint(Coverpoint):
    def __init__(self, name: str, description: str, trigger=None):
        super().__init__(name, description, trigger=None)
----

A 'setup()' method is then required to create the axes and goals of the coverpoint. This function will only be called if the coverpoint is active. 
add_axis: Requires a name, description and values.
'name': (str) Should be machine readable, containing no spaces
'description': (str): A short description of the coverpoint aim
'values': (dict|list|tuple|set): all the values/ranges to be covered by the axis

Values can be in the form of numbers or strings and are processed by the coverpoint when added. A name for each value/range will automatically be generated unless one is given. Names allow more meaning to be given to integers/ranges, while still allowing either the name or the value to be sampled. Names will be shown in the exported coverage.
To specify a name, a dictionary should be used in the form {'name': value}
Alternatively, a list, tuple or set can be passed in and the names will be automatically created.
Ranges can also be specified be providing a MIN and MAX value in a list in place of a single value. eg. [0,1,2,[3, 9], 10]

[source,python]
----
    def setup(self, ctx):
        self.add_axis(
            name="my_axis_1",
            values=[0, 1, [2, 3]],
            description="Range of values for my_axis_1",
        )
----

Goals are used to name bucket(s) and also to define ILLEGAL, IGNORE and modified hit counts.
add_goal: Requires a name, number of hits and a description
name: (str) Should be all caps, no spaces. It should also be uniquely named where possible
hits: 
    * 1+: Modify the number of hits required to saturate this bucket(s)
    * 0: Ignore. No coverage will be collected for this bucket(s)
    * -1: Illegal. Bucket(s) will generate an error if is hit

To begin, each goal is created during setup():

[source,python]
----
        self.add_goal("MOULDY_CHEESE", -1, "Not so gouda!")
        self.add_goal("OPTMISTIC_CHEESE", 20, "I brie-live in myself!")
----

If goals are created, then they must be applied to the relevant buckets. To do this the apply_goals() method must be overridden, which will be automatically called at the end of the setup phase. After filtering which buckets are to have a goal applied, the new goal should be returned. The default of 10 hits is otherwise applied. 
NOTE: The name of the bucket is used, not the original value.

[source,python]
----
    def apply_goals(self, bucket, goals):
        if bucket.my_axis_1 == "1" and bucket.my_axis_3 in ["red", "yellow"]:
            return goals.MOULDY_CHEESE
        elif int(bucket.my_axis_2) > 8:
            return goals.OPTMISTIC_CHEESE
----

Lastly, a sample() method needs to be defined. This uses a cursor to point to a particular bucket, which will have its hit count increased (if applicable).
A trace object can be of any type, but is intended to be a class continaing all information to be covered (from a monitor, model, etc). Each coverpoint can then cover the relevant information. This could be simply directly assigning values to each axis, processing the values into something more useful and/or storing values for the next time the coverpoint is called. 

The cursor should have every axis of the coverpoint set to a valid value. Attempting to sample while not setting the cursor correctly will result in an error.
To set each axis, 'set_cursor()' is used, with each axis name being assigned a value/named-value. (eg. If the values [0,1,2] were given the names [red,green,blue] then either 0 or 'red' could be assigned to the cursor).
Once all axes have been set, then the cursor can be incremented. If it is a regular bucket, then the hit count will be increased. If it is an IGNORE bucket, no action will be taken, and if it is an ILLEGAL bucket an error will be generated. 
If multiple values are to be sampled for a given call of a coverpoint, then all axes of the cursor do not need to be re-set. Only the ones which have changed need to be overridden with new values.

[source,python]
----
    def sample(self, trace):
        # 'with cursor' is used, so cursor values are cleared each time
        # cursor can also be manaually cleared by using cursor.clear()
        with self.cursor as cursor:
            cursor.set_cursor(
                my_axis_1=trace[0],
                my_axis_2=trace[1],
            )

            # For when multiple values might need covering from one trace
            # Only need to set the axes that change
            for colour in range(len(trace[2])):
                cursor.set_cursor(my_axis_3=trace[2][colour])
                cursor.increment()
----


=== Covergroups

Covergroups are a way to provide hierarchy by grouping coverpoints and other covergroups. A 'print_tree()' function can be called to display how covergroups/coverpoints are organised.

Each covergroup should inherit from the Covergroup class, and requires a 'name' and 'description'

[source,python]
----
class MyBigCoverGroup(Covergroup):
    def setup(self, ctx):
        self.add_covergroup(
            MyCovergroup(name="my_covergroup", description="A group of coverpoints")
        )
        self.add_coverpoint(MyCoverpoint(name="some_coverpoint", description="A meh coverpoint"))
----


=== Sampler (optional)

If your trace infomation requires pre-processing, then you can override the Sampler's 'process_trace() method, which by default will just return the trace object unmodified. 
eg.

[source,python]
----
class MySampler(Sampler):
    def __init__(self, coverage):
        super().__init__(coverage=coverage)

    def process_trace(self, trace):
        ...
        # Modify trace object for all coverpoints
        ...
        return trace
----


=== Adding coverage to the testbench

TO DO: GET ED TO EXPLAIN CONTEXTS!

A sampler must be initialised with a reference to the top of the coverage heierarchy (the top level covergroup). The sample() method can then be passed a copy of the trace object each time, and will then recursively call each coverpoints sample method. 

[source,python]
----
    cvg = MyBigCoverGroup(name="my_toplevel_covergroup", description="All of my coverage")

    sampler = MySampler(coverage=cvg)

    for _ in range(200):
        sampler.sample(sampler.create_trace())
----


=== Exporting coverage

At the end of each testcase, 'export_coverage()' should be called. This will dump out all ofthe coverage collected for that testcase. TO BE EXPANDED UPON ONCE SQL ADDED
